\section{Introduction}

\subsection{Contributions}

In this paper we describe our experiment in implementing an algebraic effect
for safe concurrent resource management, which we call \code{ConcState}.

The effect is implemented using the Effects library in Idris and is modelled
after the \code{LockLang} eDSL~\cite{cbconc-fi} by Edwin Brady and Kevin
Hammond.

The full code is available at
\url{https://github.com/yfyf/idris-concstate-effect}.

\subsection{Motivation}

Concurrency is a concept which is very hard to simulate in our brains.
Rephrasing my supervisor: if sequential programs have a linear state space of
$O(n)$, then concurrent programs have an exponential state space of $O(2^n)$,
which is perhaps the core issue.

Historically, either (unsafe) ad-hoc approaches have been (and mostly still
are) used or formal models were created for proving the correctness of
concurrent algorithms and then translated into an actual implementation.

Naturally, both approaches are quite unsustainable and it is a shame that,
despite having progressed research in the area quite a bit, most software
systems are still handling concurrent resources "manually" in practice (e.g.
without any hints from the compiler about deadlocks).

Hence the initial aim of this project was to explore advances in programming
language research which would help us solve these problems. This idea
crystallised into an attempt to explore the power of Dependent Types, in
particular, the way they are used in Idris and attempting to use ideas from
previous work on concurrent resource handling~\cite{cbconc-fi}, combining them
with a new \emph{effectful}~\cite{eff} approach to handling programs with side
effects as implemented in the Effects~\cite{effects-idr} library of Idris.

\subsection{Dependent Types and type safety}

Normally in programming languages types and values are kept completely
distinct. The main benefit of this approach is that type inference is much
simpler and, in fact, decidable.

However, this means that it is very hard or impossible to precisely
describe some of the data structures and flows (i.e. relations) of your
program. In a type system with dependent types, the distinction between values
and types is blurred and types are promoted to first-class citizens in
dependently typed programming languages~\cite[p.~3]{idris-tutorial}, which
means they can be manipulated as any other term.

The price one has to pay for this is that type checking can in general become
undecidable (which in addition signals a significant increase in complexity).

The good part of this is that you can describe your data with "arbitrary"
precision. A typical example of a data structure possible with dependent types
is a fixed-length list, i.e. a vector. Which could be expressed as
a Haskell-style typeclass as follows:

\begin{BVerbatim}

-- the Vect is parametrised over a length and a type
data Vect : Nat -> Type -> Type where
    -- empty vector constructor, Z stands for 0
    Nil  : Vect Z a
    -- the standard cons operator, where `S` is
    -- the natural number successor operator
    (::) : a -> Vect n a -> Vect (S n) a

\end{BVerbatim}

which makes it possible to, e.g. describe the standard "list-type" functions
such as \code{head} and append (\code{++}) very precisely:

\begin{BVerbatim}

-- ensure the vector is non-empty by matching the length as (S n)
head : Vect (S n) a -> a
head (x::xs) = x

-- carry around the vector length when appending
(++) : Vect m a -> Vect n a -> Vect (m + n) a
(++) []      ys = ys
(++) (x::xs) ys = x :: xs ++ ys

\end{BVerbatim}

\subsection{Idris}

Idris is a research language with Dependent Types conceived by Edwin Brady at
the University of St Andrews. Idris is influenced by Haskell and tries to be a
general purpose language aimed at systems programming (via easy interfacing
with C, compilation to multiple backends (C, JavaScript, Java) and various
performance optimisations).

Since my goal was to solve a practical problem of making it easier to work with
resources in a concurrent setting, Idris, due to its aims, seemed as a perfect
experimentation platform.
