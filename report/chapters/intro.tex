\section{Introduction}

\subsection{Contributions}

In this paper we describe our experiment in implementing an algebraic effect
for safe concurrent resource management, which we call \code{ConcState}.

The effect is implemented using the Effects library in Idris and is modelled
after the \code{LockLang} eDSL~\cite{cbconc-fi} by Edwin Brady and Kevin
Hammond.

The full code, together with instructions for running it, is available at\\
\mbox{\url{https://github.com/yfyf/idris-concstate-effect}}.\\
It has been tested to work with Idris version \version.

\subsection{Motivation}

Concurrency is a concept which is very hard to simulate in our brains.
Rephrasing my supervisor: if sequential programs have a linear state space of
$O(n)$, then concurrent programs have an exponential state space of $O(2^n)$.
This is perhaps our main struggle with concurrent code.

Historically, concurrent protocols and algorithms were implemented either in an
(unsafe) ad-hoc manner or formal models were employed for proving the
correctness and safety properties. In the latter case, a formal descriptions
is usually ``manually'' translated into an actual implementation. Due to the
subtle nature of concurrent algorithms, the implementation often turns out to
be unfaithful to the formal description, resulting in hard to trace bugs.

Naturally, both approaches are quite unsustainable. It is a shame that, despite
lots of research in related areas, in practice most software systems handle
concurrent resources without any static safety guarantees (e.g. without any
hints from the compiler about deadlocks).

Hence the initial aim of this project was to explore advances in programming
language research in order to address these problems. This idea crystallised
into an attempt to leverage the power of dependent types, in particular, the
way they are used in Idris. Our main goal was to combine previous work on
concurrent resource handling~\cite{cbconc-fi} in Idris with algebraic effects
(as they are implemented in the Effects~\cite{effects-idr} library).

\subsection{Dependent Types and type safety}

Normally in programming languages types and values are kept completely
distinct. The main benefit of this approach is that type inference is much
simpler and, in fact, decidable.

However, this means that it is very hard or impossible to precisely
describe some of the data structures and flows (i.e. relations) of your
program. In a type system with dependent types, the distinction between values
and types is blurred and types are promoted to first-class citizens in
dependently typed programming languages~\cite[p.~3]{idris-tutorial}, which
means they can be manipulated as any other term.

The price one has to pay for this is that type checking can in general become
undecidable (which in addition signals a significant increase in complexity).

The good part of this is that you can describe your data with ``arbitrary''
precision. A typical example of a data structure possible with dependent types
is a fixed-length list, i.e. a vector. Which could be expressed as
a Haskell-style GADT as follows:

\begin{BVerbatim}

-- the Vect is parametrised over a length and a type
data Vect : Nat -> Type -> Type where
    -- empty vector constructor, Z stands for 0
    Nil  : Vect Z a
    -- the standard cons operator, where `S` is
    -- the natural number successor operator
    (::) : a -> Vect n a -> Vect (S n) a

\end{BVerbatim}

which makes it possible to, e.g. describe the standard ``list-type'' functions
such as \code{head} and append (\code{++}) very precisely:

\begin{BVerbatim}

-- ensure the vector is non-empty by matching the length as (S n)
head : Vect (S n) a -> a
head (x::xs) = x

-- carry around the vector length when appending
(++) : Vect m a -> Vect n a -> Vect (m + n) a
(++) []      ys = ys
(++) (x::xs) ys = x :: xs ++ ys

\end{BVerbatim}

For a quick introduction to dependent types and a list of great references we
refer the reader to Jan Malakhovski's introduction~\cite{deptypes-intro}.

\subsection{Idris}

\Idris{} is a research language with full Dependent Types conceived by Edwin
Brady at the University of St Andrews. Idris is influenced by Haskell and tries
to be a general purpose language aimed at systems programming (via easy
interfacing with C, compilation to multiple backends (C, JavaScript, Java) and
various performance optimisations).

Since my goal was to solve a practical problem of making it easier to work with
resources in a concurrent setting, Idris, due to its aims, seemed to be a perfect
experimentation platform.

For an introduction to Idris please consult the Idris
tutorial~\cite{idris-tutorial}. Finer details about the core Idris can be found
in the implementation paper~\cite{idris-impl}.
