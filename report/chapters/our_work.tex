\section{An effect for managing concurrent state}

\subsection{Considerations}

The main goal of this experiment was to implement an effect for concurrent
resource management in order to make use of the Effects library, in particular
the composability brought by using algebraic effects in general.

Ideally, one would probably want to have an effect similar to \code{STATE}
for managing an arbitrary resource associated with some state and also
thread-safety sprinkled on top. This would be easy to do if we only had
\emph{one} resource to manage, however since we are dealing with a set of
\emph{ordered} resources (i.e. like in the CbC paper), this is not possible, at
least in the current Effects library, because effects live in isolation, i.e.
it's impossible to reference other effects from within the definition of one.

Hence we are forced to have a combined state (or an "environment") for managing
all the resources, though this is not much of an issue and is essentially the
same approach which is taken in the CbC paper.

Due to exactly the same reasons, although we might want to have forking as an
effect on its own (which e.g. executes an effectful program in some "parallel"
computational context, allowing to write handlers which perform different
interleavings and etc.), this is not possible if we want to provide the safety
guarantees. (And in fact forking induces additional and more fundamental
issues, as we will see latter).

\subsection{The predicates}

As a consequence of the considerations, we model the management of a collection
of resources in a very similarly to to how it was done in the CbC paper.

Our first ingredient in constructing the effect is the type for
\emph{representing} the state of a resource, which will be used to in
describing the various safety conditions.

\begin{SaveVerbatim}{resstate}

data ResState = RState Nat  -- number of times a resource has been locked.
                       Type -- type of resource

\end{SaveVerbatim}
\useverb{resstate}

We will represent a collection of resources that we want to manage safely as a
vector, i.e. \code{Vect n ResState}.

Next come data predicates and functions which we shall use to ensure, at the
type-level, that certain conditions on the resources hold.

\code{ElemAtIs} is a generic predicate for ensuring that the element at
position $i$ of a vector of length $n \geq i$ equals to some element \code{el}.

[Note: Here \code{Fin n} is a type for natural numbers up to $n$, with constructors
\code{fZ} (for $0$) and \code{fS} (for successor).]

\begin{SaveVerbatim}{elematis}

data ElemAtIs: (i: Fin n) -> (el: a) -> Vect n a -> Type where
  ElemAtIsHere:  {x: a} -> {xs : Vect n a} -> ElemAtIs fZ x (x::xs)
  ElemAtIsThere: {i : Fin n} -> {x: a} -> {xs: Vect n a} ->
                                ElemAtIs i x xs ->
                                ElemAtIs (fS i) x (y::xs)

\end{SaveVerbatim}
\useverb{elematis}

The \code{prevUnlocked} function checks whether all resources up to and
including some index are unlocked (i.e. lock count is 0).

\begin{SaveVerbatim}{prevunlocked}

prevUnlocked: Fin n -> Vect n ResState -> Bool
prevUnlocked fZ (x :: xs) = True
prevUnlocked (fS k) (RState Z t :: xs) = prevUnlocked k xs
prevUnlocked _ _ = False

\end{SaveVerbatim}
\useverb{prevunlocked}

Finally, the \code{allUnlocked} function checks that all the resources in a
collection are unlocked.

\begin{SaveVerbatim}{allunlocked}

allUnlocked: (xs: Vect n ResState) -> Bool
allUnlocked [] = True
allUnlocked ((RState Z t) :: xs) = allUnlocked xs
allUnlocked _ = False

\end{SaveVerbatim}
\useverb{allunlocked}

\subsection{Interpreters and the environment}

In order to associate a \code{ResState} resource representation with some
concrete values, we shall use data type constructor of the form
\code{ResState -> Type}. We shall call constructors of such type
\emph{interpretations} of resources (i.e. \code{ResState}s).

For the sake of simplicity, we used an interpreter which only
supports \code{Int} resources:

\begin{SaveVerbatim}{resource}

data Resource: ResState -> Type where
     resource: (lock_count: Nat) -> LockRef ->
                    (Resource (RState lock_count Int))

\end{SaveVerbatim}
\useverb{resource}

It is parametrised over a lock reference \code{LockRef}, which will be used to
access the locks and resource data via a small library we implemented for
demonstration purposes. It is also parametrised over an explicit lock count,
since our library doesn't actually support nested locks, so we only keep the
lock count for simulation purposes.

Furthermore, we combine the interprations of the resource states (i.e.
\code{Vect n ResState}) into a resource \emph{environment} \code{REnv}:

\begin{SaveVerbatim}{renv}

REnv: (xs:Vect n ResState) -> Type
REnv xs = ConcEnv ResState Resource xs

\end{SaveVerbatim}
\useverb{renv}

where \code{ConcEnv} is a generic environment constructor, defined as:

[Note: we use the name \code{ConcEnv} instead of just \code{Env} to avoid
confusion with environments associated with effects in the Effects library.]

\begin{SaveVerbatim}{renv}
data ConcEnv: (t: Type) -> (iR: t -> Type) -> (xs: Vect n t) -> Type where
   Empty:  {iR: t -> Type} -> ConcEnv t iR []
   Extend: {r: t} -> {iR: t -> Type} -> {xs: Vect n t} ->
                     (res: (iR r)) -> ConcEnv t iR xs ->
                     ConcEnv t iR (r::xs)
\end{SaveVerbatim}
\useverb{renv}

where \code{iR} is a generic interpretation function.

Finally, we have functions to access and modify the environment:
\code{envLookup}, \code{envLock} an \code{envUnlock}.

As an example, here is the definition of \code{envUnlock}. Note that we are
providing a proof that the element to which we are writing is locked:

\begin{SaveVerbatim}{envLookup}

    envLookup: (REnv rsin) -> (i: Fin n) ->
        (proof: ElemAtIs i (RState (S k) ty) rsin) -> LockRef
    envLookup (Extend (resource _ r) _) fZ ElemAtIsHere =
        r
    envLookup (Extend r rsin) (fS i) (ElemAtIsThere foo) =
        envLookup rsin i foo

\end{SaveVerbatim}
\useverb{envLookup}

Note: although the \code{REnv} and, e.g. \code{envLookup} are implemented in a
way which directly depends on our \code{Resource} interpretation and hence
make it seem impossible to provide other interpretations, this can be easily
abstracted using e.g. a typeclass for such interpretations, but we avoided this
approach for simplicity and flexibility (i.e. this induces more tedious work
for writing alternative versions of the \code{env*} functions, but allows one
to have any kind of interpreter).

\subsection{The effect}

We finally arrive at the actual definition of the \code{ConcState} effect.

For reasons explained later, we parametrise \code{ConcState} over a
computational context \code{(m: Type -> Type)}:

\begin{verbatim}
    data ConcState: (m: Type -> Type) -> Effect where
\end{verbatim}

The effect will have 5 actions: \code{Lock}, \code{Unlock}, \code{Read},
\code{Write} and \code{Fork}.

The first 4 definitions are rather straightforward and there is little to
comment on: for each action we ask for a proof of necessary conditions to be
provided explicitly and ensure that the resource state is updated accordingly.

[Note: in all of the remaining code, the variable \code{rsin} is of type
\code{Vect n ResState} (declared with the \code{using} notation of Idris).]

\begin{verbatim}
-- Lock a shared variable.
-- Must know that no lower priority items are locked, that is everything
-- before 'ind' in rsin must be unlocked.
Lock: (ind: Fin n) -> (ElemAtIs ind (RState k ty) rsin) ->
      (PrevUnlocked ind rsin) ->
      ConcState m (REnv rsin)
                (REnv (replaceAt ind (RState (S k) ty) rsin))
                ()
-- Unlock a shared variable. Must know it is locked at least once.
Unlock: (ind: Fin n) -> (ElemAtIs ind (RState (S k) ty) rsin) ->
      ConcState m (REnv rsin)
                (REnv (replaceAt ind (RState k ty) rsin))
                ()
-- Read from a locked variable.
Read: (ind: Fin n) -> (ElemAtIs ind (RState (S k) ty) rsin) ->
    ConcState m (REnv rsin) (REnv rsin) ty
-- Write to a locked variable.
Write: (ind: Fin n) ->
        (val:ty) -> (ElemAtIs ind (RState (S k) ty) rsin) ->
        ConcState m (REnv rsin) (REnv rsin) ()
\end{verbatim}

However, figuring out the right type for \code{Fork} is more challenging and
poses several questions. Since we are working with a functional programming
language, we will want to pass a function to be executed in the new thread.
However, in this setting we need to ensure that once the thread execution
finishes, the resource states are the same as they were initially.

[@TODO: explain that \code{CONCSTATE} and \code{ConcState} are defined with
mutual recursion, by using:
\begin{verbatim}
CONCSTATE : Vect n ResState -> (Type -> Type) -> EFFECT
CONCSTATE rsin m = MkEff (REnv rsin) (ConcState m)
\end{verbatim}
]

Hence, instead of an arbitrary function, we want to pass an effectful program,
which leaves the state of resources unchanged. Furthermore, it would be
problematic to safely and usefully handle a return value of a thread, so we
assume the functions output is a unit.

A naive type for such a program is: \code{Eff m [CONCSTATE rsin m] ()}. We will
use it for now and discuss problems raised by enforcing this type of programs
only later.

We can then define \code{Fork} as follows:
\begin{verbatim}
-- We allow forking only when all resources are unlocked, which is
-- guaranteed to be safe
Fork : {m: Type -> Type} -> (proof: AllUnlocked rsin) ->
        (prog: Eff m [CONCSTATE rsin m] ()) ->
        ConcState m (REnv rsin) (REnv rsin) ()
\end{verbatim}

\subsection{The handler(s)}

Perhaps the most beautiful thing about Effects is the ability to define
different handlers. %% @TODO: oh man...

We present here as an example the "standard" \code{IO} handler. Once again, the
handling of \code{Lock}, \code{Unlock}, \code{Read}, \code{Write} is
straightforward:

\begin{verbatim}
instance Handler (ConcState IO) IO where
    handle env (Write ind val prf) k = do
        let newenv = envWrite env ind val prf
        k newenv ()
    handle env (Read ind prf) k = do
        let val = envLookup env ind prf
        k env val
    handle env (Lock ind prf_elem prf_unlocked) k = do
        let newenv = envLock env ind prf_elem
        k newenv ()
    handle env (Unlock ind prf) k = do
        let newenv = envUnlock env ind prf
        k newenv ()
\end{verbatim}

Note that \code{env} and \code{newenv} here are environments in the
\code{ConcEnv} sense, NOT in the Effects sense, i.e. environments corresponding
to the shared resources in the \code{ConcState}.

\code{Fork} is perhaps a bit more cryptic and magical:

\begin{verbatim}
    handle env (Fork prf prog) k = do
        let _ = fork (run [env] prog)
        k env ()
\end{verbatim}

Let us dissect it:

\begin{itemize}
    \item \code{fork} is an \code{IO} primitive available in Idris which forks
        a program of type \code{IO ()} to be executed in a new thread.
    \item \code{run} is part of the Effects library, it is used to run an
    effectful program and has the type:
    \begin{verbatim}
run : Applicative m => Env m xs -> (prog: EffM m xs xs' a) -> m a
    \end{verbatim}
    so the term \code{[env]} \emph{is} now actually an Effects \code{Env}.
\end{itemize}

Furthermore, now it can be seen why we parametrised \code{ConcState} over
a computational context \code{(m: Type -> Type)}: we want to ensure that we only
fork \code{CONCSTATE} subprograms which will be run in the same computational
context as the parent \code{CONCSTATE} program. [Note: I believe it might be
possible to avoid this, but I did not explore this enough as it was not the
main concern.]

Moreover, observe that the only reason we need to run this in an \code{IO}
monad is because we are using \code{fork}. If, e.g. we changed the handling of
\code{Fork} to be, e.g. sequential:

\begin{verbatim}
    handle env (Fork prf prog) k = do
        let _ = run [env] prog
        k env ()
\end{verbatim}

we could have a generic instance which could be run in any \code{Applicative
m}\footnote{The restriction that \code{m} must be an instance of
\code{Applicative} can't be dropped, because of the type of \code{run}}.

Finally, we can define the basic actions as standalone effectful programs
(using the implicit lifting used in the Effects library). Here is how
\code{write} and \code{efork}\footnote{the \code{e} prefix is used to avoid
confusion with the IO primitive \code{fork}} are defined:

\begin{verbatim}
write: (ind: Fin n) -> (val: ty) -> (ElemAtIs ind (RState (S k) ty) rsin) ->
            Eff m [(CONCSTATE rsin m)] ()
write i val el_prf = (Write i val el_prf)

efork: {rsin: Vect n ResState} -> (prf: AllUnlocked rsin) ->
            Eff m [CONCSTATE rsin m] () -> Eff m [CONCSTATE rsin m] ()
efork prf prog = (Fork prf prog)
\end{verbatim}

@TODO: mention that it would be possible to add some tactics here so that
explicit proofs would not be needed.

\subsection{The problems}

\emph{@TODO: Figure out: if we didn't have other problems, would the
restriction to a single computational context be an issue? Can effects switch
computational contexts during execution?}
